Name: Armant Touche
Class: CS 163
Instructor: Karla Fant
Description: Program #4 Efficiency Write-up

	Binary Search Tree worked for alphabetically sorting the node’s information and in our case, I went with sorting by name of meal since that is a more unique. As far as being balanced and complete, my binary search tree didn’t do so well in that aspect because there isn’t a auto-balancing property of the insertion function like 2-3-4 tree data structure. The reason why I mentioned this is because in a worst case scenario for the search function, the furthest node may be the match and if the tree isn’t efficient, I practically have linear search efficiency of O(N) which is similar to Linear Linked List. If the tree was balanced, then there would be a O(log _2) efficiency which is the best characteristic of Binary Search Trees. Getting back to the original point, the sorted insertion property of Binary Search Trees is awesome for this assignment and learning how to properly sort. One downside to that, the Binary Search Tree sorted-insertion could turn this data structure into a something that resembles a linear linked list. I would like to understand how to better approach the efficiency aspect in regards to in deleting many nodes or just one because I am still having trouble with segmentation faults in regards to delete all nodes matching user’s given location. I implemented my search recursively but the deletion of single works well in conjunction with search function. This constant memory fetches maybe another downside to Binary Search Tree since I am constantly having to create temp pointer to hold and delete matching nodes. I think Red-Black insertion function’s property, rotating sub-trees, could have a better benefits. 
	The design of my program was short and simple and I ended up recycling lot of the functions from assignment #3 in regards to the client interface and application. The only work that needed to be done was prototyping and implementing the Binary Search Tree Abstract Data Type which lab #7 covered pretty well except for deletion operation. Deletion operation are the bane of this program and if I had more time, I would spend my effort understanding deletion algorithm but the pace of the class is fast for a novice like me. Carrano’s chapters does a pretty good job of covering the cases for deletion which he uses a lot of pseudo-code, which is awesome. My insertion, display name, and display sorted functions were good-to-go but my two deletion function weren’t. I have no memory leaks according to valgrind but the graders seem to find them where I don’t look for them at.
	What would I do differently for this assignment? Maybe a 2-3 tree would work great but the complexity of that data structure at our current level would probably be too much for me but from a high-level viewpoint, I think that a 2-3 tree would work good since memory efficiency isn’t a constraint on these assignments. Again, why I say 2-3 tree would be great for this assignment is simply  because the ample room for improvement in balancing the tree is needed. I started off great with designing and implementing the Binary Search Tree and when it came to my last function to implement, which was the is-efficient function, I felt pretty confident about my program and effort spent in the design phase. If I had more time, I would spend more time on implementing a balance-add function which would. The recursive algorithm for removal of a single node is was a little monotonous when came to the third case. I had more time, I would seek areas for improvement which is always the case for these assignments.

