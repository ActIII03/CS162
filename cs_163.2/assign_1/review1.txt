Name: Armant Touche
Class: CS 163
Instructor: Karla Fant
Description: Program #1 Efficiency Write-up

   Program one was to store information about a Smart home where the Abstract Data Type's data structure was two Linear Linked List. First Linear Linked List is a list of the rooms inside the Smart home sorted by name alphabetically and the second list is a list of accessories, sorted by category. The fixed memory issue that usually associated with static arrays was not an issue with the data structure. Each creation of a room and accessory item was dynamically allocated and Abstract Data Type did not need a size before run time. But, with that said, insertion, search and removal requires traversal, disregarding our lists being alphabetically sorted. For each list, we still need to traverse out list. For static arrays, direct access result in efficiency O(1) where efficiency for the Linear Linked List results in O(N). Depending on the number of data items, this list could contain millions of items. That would take a while to do any of the above operations. For this, I would have went with a hash-table paired with chaining, where the chain/Linear Linked List would be the accessories and each indices would be a room in a Smart room. Although, searching for accessories in a hash table in which the chaining/Linear Linked List at each indices would result in the same performance in our original data structure for this program. The dynamic characteristic if not having to knowing the required size is an additive positive to Linear Linked List.
    Would a different data structure  work better? Depends on the operation of the Abstract Data Type we chose to examine and measure efficiency. The insertion function for our Abstract Data Type requires we have to traverse and compare at each node with string-compare. This operation alone is one of the downsides of Linear Linked List. Imagine having a Linear Link List that contained one million items. Worse, what if the second to last node is the item the user wishes to search for? That would take some considerable processing resources to do that search. The same goes for the removal operation. That too, would take some considerable processing resources. The display all function and display a single room are also inefficient because the linear property of Linear Linked List. 
    I took time with my interface and choose to design from a high-level or top-down approach. I was able to come up good sense of what operations that were necessary to both Abstract Data Type and the Client Program. Once my design was solid and I felt confident, I switched to a bottom-up approach for the  implementation of both the Abstract Data Type's operations and the Client program's function implementation. I started with just inserting rooms into a Linear Linked List and removing a room from the Linear Linked List. Then I moved on to displaying every room and displaying a single room. Once finished with that, I moved on to inserting accessories into a room. This part was not too bad implementing but I had to do a couple pointer diagrams in order to get better sense of what I was working with. I did most of my insert and delete functions recursively except for inserting an accessory. I settled with doing it iteratively. If I had more time, I would try to implement all my Abstract Data Type's operations recursively. Other than that, I feel pretty confindent but who knows when it comes to memory leaks. The amount of time I have already poured into this assignment was not too crazy because I took my time in the design process and finished lab 1 & 2 which the operations from those labs were directly related to the homework assignment assigned to us.
