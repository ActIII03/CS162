Name: Armant Touche
Class: CS 163
Instructor: Karla Fant
Assignment: Program 2 Effieciency Write-up

 Stack and Queues worked fine for program three being the stack metaphor ties well into Trivial Pursuit. Pushing to the stack and queuing was easy since I knew exactly the amount of cards and question being inputted from the text file. My stack and queue functions of the ADT were re-usable but I didn't get to implement dequeue. I simply created a deep copy and deleted the previous original queue all three questions and answers at once instead of dequeueing them individual which will be counted against me but I could figure out to dequeue from the queue before popping the card entirely. I would spend time figuring out how to dequeue but I had to submit my assignment. The direct access of the stack was nice and I didn't have to traverse like a Linked List which was nice. The queue mixed with a circular linked list(CLL) was interesting and I do like the fact I do not have to worry about the last node not being set to NULL since the rear holds the linked list together. I rarely encountered segmentation faults which queuing the questions and answers which was nice but special consideration was taken when adding to the CLL but nothing too complex. I wish accessing the queue was a little bit more straightforward and wasn't convoluted in regards to pointers and to access the queue nodes in the CLL. Accessing the CLL was the biggest headache because the private characteristics of classes in C++.
	I think for this program, stacks and queue fit the data requirements perfectly and I wouldn't think to use a different data structure because I only know a couple and I think the challenge of implementing stacks and queues was good enough for us to learn how a commonly used data structure is implemented.  Honestly, I do not what would be more efficient for this type of program but I wouldn't change my data structure to something different.
	When designing, I had a lot of trouble at the beginning envisioning the interface for ADT because I was behind the learning curve for stacks and queues but I went to an extra lab and the lab assistants explained implementation perfectly which I should have done earlier but lesson learned. Do not wait last minute to learn how the ADT works for Stacks and Queues. After attending a practice lab for Lab #3, I finally realize how they work together and what to put into my ADT interface for my stack and queue. For stacks push function, I didn't know the order in which the to create a new stack after the first stack reached max capacity but I had some help from the tutors.  
	One of the inefficient portions of my program would have to be the lack of having a dequeue function and how I display the questions to the user. I used look-head's for my display function which requires several fetches making the display-portion inefficient. The deep copy of the queue before before I started a right or wrong stack was extra memory used. I could have just dequeue them properly and push each question one by one but I couldn't figure out how to dequeue properly. 
	I would spend more time designing my ADT interface and learning the implementation of the ADT function for stacks and queues. Specifically, spend more time on the the push, pop, queue, and dequeue functions. I wish I could have spent less time figuring out how to implement certain functions that were giving me a hard time but that was fault for not being verse in stack and queue implementation. 
