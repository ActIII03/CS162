Name: Armant Touche
Class: CS 163
Instructor: Karla Fant
Design Write-up Purpose: The Main question are answered first in a General Sense in relation to ADT and how I intend to successfully hide the information. Also, I plan to go into more detail afterward the questions to describe the logic and the program flows. Attached is my test cases for my functions, both procedural and object methods.

Main Description: 

a. What functions your ADT will need in the public and private sections
  
    Answer: I make a procedural function to get read data from user and pass the data by reference to my FoodCartList object's function Add Cart. Doing this will prevent the application in main from touching the LLL in the private section of my FoodCartList object.

b How each function will report success/failure back to the calling routine

    Answer: I will have integer return value either one(failure) or zero(success).

c. How my functions will shield the client program from the details of the data structure

    Answer: With my read in function, Get Character, will be outside the FoodCartList class, enabling information hiding,
 
d. What data structure will I be using and how each of the special cases will be tested?

    Answer: I will be using a Linear Linked List with a head and tail pointer. Test Cases are described in my functions.

Global Variables: 

For global variables, I want to create array sizes for each data memember that will act a temporary buffer before compying them into my food cart node belonging to two struct I will, which are: (1) address (2) food cart. Following are the integer variable: (1) char buffer with static size of 200.

Main Algorithm:

    After creating objects I will invoke a menu interface that is accepts integer values from the user. Create an integer variable called decision and initialize it to zero. I want to keep the program running for the user while decision isn't an integer value of eight, which the quit option in my menu options. The following will be my menu options invocation: Invoke (1) Add Cart along with top favorite food (2) Display Carts (3) For an existing cart, delete favorite food (4) For an existing cart, add favorite food (5) Delete Cart (6) Display Cart by type of Food (7) Quit Program. If decision still doesn't equal an integer value of eight then invoke Menu module to run the program again, otherwise, quit program.

Structures:

    Create a struct object (I) cart_address: (1) Address Line 1:  var -> address_line_1; data type is character w/ a pointer (2) City; var -> address_city; data type is character w/ a pointer (3) State: var -> address_state; data type is character w/ a pointer (4) Zip Code: var -> address_zip_code; data type is character w/ a pointer. 

    Create a struct object (II) food_cart: (1) Name of Cart; var -> name_cart; data type is character w/ a pointer   (2) Location; struct_var cart_address; data type is character w/ a pointer (3) Resturant Style: var -> resturant_style; data type is character w/ a pointer (4) Review: var -> review; data type is character w/ a pointer (5) Top, Favorite Food: var -> fav_food; data type is character w/ a pointer.

    Create a struct object (III) node: (1) Food cart struct variable; var -> food_cart new_cart; data type is struct (2) node w/ dereference operator, pointing to node; var -> node * next; data type is self referencing.

Procedural Functions:

    (1) Greeting:

        Greet user with a message informing them about this program.

        Test Cases: NONE

    (2) Menu:
        
        Ask user to pick from the menu options (1-8) and read in from user a integer value into decision variable passed through the menu() paramters by reference. Return an integer value to main for the switch case in main as decision. 

        Test Cases: NONE

    (3) Get Character entry (Parameter: Pointer that will be passed by reference -- char buffer):

        This method will be called to get character input from user. I have to make sure to clear buffer after each input to clear up buffer, which prevent input failures. Return one if unsuccessful, otherwise, return zero for success

        Test Cases: (i) Case: User inputs integers Results: Invalid buffer entry (ii) Case: User does not input anyting Results: Empty buffer

FoodCartList Class Description:

    Public Members & Functions:
        
        Functions: 

            (1) Add Food Cart w/ Top Favorite (i) Parameters are: (a) const node & n_cart (ii) Function type is integer:
            
            Inform user that the following information will be needed in order to input a new food cart:  Read in inputs from user into each member of the food struct via the pointer present in the private section of the FoodCart class. since this method, Add Cart, is within the same class as the. First base case that would prevent this method from being reused and not worry about the head, is if this list was empty and the head pointer is set to NULL. If head is equal to NULL, before I go to into my statements I will declare the following: (i) node * n_cart and set it equal to head (ii) node * temp and set it equal to head. When I enter my first statement case, I will declare pointer to the n_cart pointer and create a new node object via the new operator setting the n_cart equal to new node. Set head equal to n_cart to start a Linear Linked List (LLL). So, the previous was the first case for adding to our LLL, otherwise, we will first get character by invoking one of the procedural modules to fill buffer with each input from the user filling the data member. Return one if unsuccessful, otherwise, return zero for success.

            Test Cases: NONE

            (2) Display Carts -- (i) Parameters are: NONE (ii) Function type is integer:

                If food cart list is empty then let user know that list is empty. Otherwise, start with head pointer and recursively display each by calling self-calling this current method with the argument being: (i) An indirect operator point to the next node until end of list is reach. Return one if unsuccessful, otherwise, return zero for success. 

                Test Cases: NONE

            (3) For an exisitng each Cart, Delete Favorite Food (i) Parameters are: (a) char * delete (ii) Function type is integer:

                I will invoke the Get Character module to get both the cart they want and the their delete choice. I will copy the buffer into two variables: (i) food_cart (ii) del_food. Then I will traverse the LLL until string compare returns a True. If there is a match, then I will delete their favorite food from their choice of cart, otherwise, nothing will happen. If no match, then I will inform the user. Return one if unsuccessful, otherwise, return zero for success

                Test Cases: NONE

            (4) For an existing cart, Add Favorite Food  (i) Parameters are: (a) const node & n_cart (ii) Function type is integer:

               I will invoke the Get Character module to get both the cart they want and the their added choice. I will copy the buffer into two variables: (i) food_cart (ii) add_food. Then I will traverse the LLL until string compare returns a True. If there is a match, then I will add their favorite food from their choice of cart, otherwise, nothing will happen. If no matching cart is found, then I will inform the user that there is no cart. Return one if unsuccessful, otherwise, return zero for success

               Test Cases: NONE

            (5) Delete Cart  (i) Parameters are: (a) const node & n_cart (ii) Function type is integer:

                Invoke Get character module to get user deletion choice. If list is empty then I inform the user that the list is empty. If there is a list then I do a string with the food cart name and if there is a match, then I delete that cart entry. If there isn't a match then I inform the user that their deletion choice is not present in the list. Return one if unsuccessful, otherwise, return zero for success

                Test Cases: NONE

            (6) Display Cart by Type of Food  (i) Parameters are: (a) const node & n_cart (ii) Function type is integer:

                Invoke Get character module to get user foo_type choice. If list is empty then I inform the user that the list is empty. If there is a list then I do a string with the food_type and if there is a match, then I carts with the same food_type. If there isn't a match then I inform the user that their food_type choice is not present in the list. Return one if unsuccessful, otherwise, return zero for success.

                Test Cases: NONE

            (7) Destory (i) Parameters are: (a) const node & n_cart (ii) Function type is integer

                If the list is empty then return nothing, otherwise, create a temp pointer and set temp equal to the head and delete head. Self-call making sure to pass temp through the arugement.

                Test Cases: (i) Case: List is empty Results: Nothing to destory

            (8) FoodCartList constructor  (i) Parameters are: NONE (ii) Function type is integer:

                       Initialize the following variables: (1) Set the head pointer equal to NULL (2) Set the tail pointer equal to NULL

                       Test Cases: NONE

            (9) FoodCartList destructor  (i) Parameters are: NONE (a) const node & node (ii) Function type is integer:

                    If there is no list then return nothing, otherwise, I will invoke a helper function destroy passing the head through the argument. 
                    
                    Test Cases: NONE

        Members:

            NONE

    Private Members & Functions:

        Functions:

            NONE

        Members:

            I want to create the following variables: (1) food cart struct head pointer: var -> food_cart * head; data type is *INSERT_HERE* (2) food cart struct tail pointer: var -> food_cart * head; data type is *INSERT_HERE*.
