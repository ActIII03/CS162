Name: Armant Touche
Class: CS 163
Instructor: Karla Fant
Description: Program #4 Efficiency Write-up

	Binary Search Tree worked for alphabetically sorting the node’s information and in our case, I went with sorting by name of location since that is a more unique. As far as being balanced and complete, my binary search tree didn’t do so well in that aspect because there isn’t a auto-balancing property of the insertion function in 2-3-4 tree data structure. The reason why I mentioned this is because in a worst case scenario for the search function, the furthest node may be the match and if the tree isn’t efficient, I practically have linear efficiency of O(N) which is present in a Linear Linked List. Getting back to the original point, the sorted property of Binary Search Trees is awesome for this assignment. I would like to understand how to better approach the efficiency aspect in regards to in deleting many nodes or just one because I am still having trouble with segmentation faults in regards to delete all nodes matching user’s given location. I implemented my search recursively but the deletion of single works well in conjunction with search function. This constant memory fetches maybe another downside to Binary Search Tree since I am constantly having to create temp pointer to hold and delete matching nodes. I think 2-3 insertion function’s property, bubbling up nodes, could have a better cost benefits. 
	The design of my program was short and simple and I ended recycling lot of the functions from assignment #3 in regards to the client interface and application. The only work that needed to be done was prototyping and implementing the table Abstract Data Type which lab #7 covered pretty well except for deletion operation. Deletion operation are the bane of this program and if I had more time, I would spend my effort understanding deletion algorithm but the pace of the class is fast for a novice like me. Carrano’s chapters does a pretty good job covering the cases for deletion which he uses a lot of pseudo-code, which is awesome. My insertion, display name, and display sorted functions were good-to-go but my two deletion function weren’t. I have no memory leaks according to valgrind but the graders seem to find them where I don’t look for them at.
	Different for assignment? Maybe a 2-3 tree would work great but the complexity at our level, 163 lvl., is too much for me but from a high-level viewpoint, I think that a 2-3 tree would work good since memory efficiency isn’t a constraint on these assignments. Again, why I say 2-3 tree would be great for this assignment is simply  because the ample room for improvement in balancing the tree is needed. I started off great with designing and implementing the Binary Search Tree but when I had to start implementing deletion function, I fumbled a lot. If I had more time, I would spend more time on the deletion functions but I will get to practice more in CS 299 and I hope to get a better understanding from that class before ascending to CS 202 and further. The iterative algorithm for removal of a single node is monotonous which if I had more time, I would implemented a recursive function seeing that the third case, being the desired node to remove has two children has a less tedious, recursive-solution that does not require many memory fetches as the iterative solution for third case. The memory efficiency for the iterative solution is more costly when I used it because I did a lot of look head's for traversal to the in order successor.  All in all, I like this program and I wouldn’t mind spending more time on it.

